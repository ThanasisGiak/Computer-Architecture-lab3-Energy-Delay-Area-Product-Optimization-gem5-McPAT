# Computer-Architecture-lab3-Energy-Delay-Area-Product-Optimization-gem5-McPAT
# 3η Εργαστηριακή Άσκηση Αρχιτεκτονικής Υπολογιστών

## Energy-Delay-Area Product Optimization (gem5+ McPAT)

#### Γιακουμάκης Αθανάσιος ΑΕΜ 8554

#### Θεοδοσιάδης Κωνσταντίνος ΑΕΜ 8296

### Ερωτήματα Τρίτου Μέρους

#### Βήμα 1ο

Σε αυτό το βήμα ακολουθήσαμε τις οδηγίες που μας δινόντουσαν από την εκφώνηση της άσκησης και εγκαταστήσαμε το εργαλείο McPAT χρησιμοποιώντας την εντολή:

>git clone https://github.com/kingmouf/cmcpat.git my_mcpat

και τρέξαμε το εργαλείο με διάφορα από τα αρχεία εισόδου xml που έχει μέσα προεγκατεστημένα έτσι ώστε να παρατηρήσουμε τι αποτελέσματα παράγει.

#### Ερώτημα 1

Ο όρος dynamic power είναι η ισχύς που απαιτείται για για να φορτιστούν και να αποφορτιστούν τα χωρητικά φορτία όταν ενα κύκλωμα αλλάζει καταστάσεις.Υπολογίζεται από τον τύπο:

>P(dynamic power)=**a**x**C**x**Vd**x**ΔV**x**fclk**

Το **C** είναι η συνολική χωρητικότητα,το **Vd** η τάση τροφοδοσίας,
το **ΔV** η μεταβολή της τάσης κατα την εναλλαγή καταστάσεων,το **fclk** η συχνότητα του ρολογιού και ο παράγοντας **a** εκφράζει το κομμάτι που φορτίζεται σε ένα κύκλο από την συνολική χωρητικότητα του κυκλώματος.Η συνολική χωρητικότητα **C** εξαρτάται από τον σχεδιασμό που έχει κάθε ενσωματωμένο στο κύκλωμα.

Ο όρος leakage,που ονομάζεται και static power,αντιπροσωπεύει την διαρροή ρεύματος των transinstors. Υπάρχουν δύο διακριτά είδη διαρροών των οποίων τα ρεύματα διαρροής εξαρτώται από το πλάτος του transistor και από την λογική κατάσταση της μηχανής.Είναι η subthreshold leakage,η οποία συμβαίνει όταν ένα transistor το οποίο βρίσκεται σε off state αφήνει ρεύμα να το διαρρέει,και η gate leakage η οποία είναι η διαρροή ρεύματος που συμβαίνει στις πύλες του transistor.Το leakage υπολογίζεται από τον τύπο:

>P(leakage)=**Vd**x**I(lkg)**

όπου **Vd** είναι η τάση τροφοδοσίας και **Ι(lkg)** είναι το ρεύμα διαρροής.

Όταν τρέξω διαφορετικά προγράμματα σε ένα επεξεργαστή θα επηρεαστεί το dynamic power εφόσον κάθε ένα μπορεί να απαιτεί διαφορετικό αριθμό εναλλαγών καταστάσεων των κυκλωμάτων.Ο όρος leakage θα παραμείνει σταθερός.Επίσης,ο χρόνος εκτέλεσης του προγράμματος δεν επηρεάζει απαραίτητα κάποιον όρο αφού η μεταβολή του δεν συνδέεται απόλυτα με το πλήθος των εναλλαγών καταστάσεων.

#### Ερώτημα 2

Είναι πιθανό ο δεύτερος επεξεργαστής να δίνει στο σύστημα μεγαλύτερη διάρκεια μπαταρίας γιατί μπορεί να είναι πιο ενεργειακά αποδοτικός από τον πρώτο.Στην ούσια ο όρος energy efficiency αυτό που εκφράζει σε ένα σύστημα είναι η αναλογία μεταξύ της εισόδου,από άποψη ενέργειας,και της χρήσιμης εξόδου που παράγει.Στο επίπεδο των επεξεργαστών ενάς τρόπος μέτρησης του όρου energy efficiency ειναι η απόδοση ανα watt(perfomance per watt),ο οποίος μετράει την αναλογία των διεργασιών που μπορεί να φέρει εις πέρας ένα επεξεργαστής για κάθε watt που καταναλώνει.Βέβαια,ο πιο διαδεδομένος τρόπος μέτρησης του energy efficiency είναι ο FLOPS per watt από τον οποίο προκύπτει και η λίστα GREEN 500 η οποία κατατάσσει του TOP500 υπερυπολογιστές σε σχέση με το πόσο ενεργειακά αποδοτικοί είναι.Άρα,δεν μπορούμε να απαντήσουμε σιγουριά ποιος επεξεργαστή από τους δύο δίνει στο σύστημα μεγαλύτερη διάρκεια μπαταρίας εφόσον δεν έχουμε στοιχεία για το τι απόδοση έχει ο καθένας.Δυστυχώς,ούτε ο McPAT με τα αποτελέσματα που παραγεί μπορεί να μας δώσει συγκεκριμένη απάντηση.Για να μπορούμε να συμπεράνουμε ποιος από τους δύο επεξεργαστές είναι περισσότερο energy efficient θα έπρεπε να ξέρουμε πόσο χρόνο παίρνει στον καθένα να τρέξει την ίδια διεργασία-προόγραμμα.Αυτήν την πληροφορία μπορούμε να την αντλήσουμε από τον gem5,αν ξέραμε την αρχιτεκτονική του κάθε επεξεργαστή,από το **stats.txt** που παράγει και πιο συγκεκριμένα το πεδίο **sim_seconds**.Έτσι,συνδιάζοντας τα αποτελέσματα των McPAT και gem5 θα μπορούσαμε να υπολογίσουμε την ενέργεια του κάθε επεξεργαστή πολλάπλασιάζοντας:
(Runtime Dynamic)*sim_seconds

Προφανώς,όσο πιο μικρό τόσο πιο energy efficient είναι ένας επεξεργαστής.Τα **Runtime Dynamic** και **Total Leakage** βρίσκονται στα αποτελέσματα που παράγει ο McPAT,το **sim_seconds** στο αρχείο **stats.txt** που παράγει ο gem5 μετά από μία εξομοίωση.

#### Ερώτημα 3

Αρχικά,τρέξαμε το McPAT για τους επεξεργαστές Xeon και ARM A9 για print level ίσο με 5 και μελετήσαμε τα αποτελέσματα.Σύμφωνα με την εκφώνηση ο Xeon τρέχει την ίδια εφαρμογή με τον ARM A9 40 φορές πιο γρήγορα,οπότε αν κάνουμε την παραδοχή ότι ο Xeon την τρέχει σε χρόνο X seconds(exec_time_Xeon) τότε ο ARM A9(exec_time_ARM_A9) την τρέχει σε χρόνο 40Χ seconds.Για να υπολογίσουμε το energy efficiency του καθενός εντοπίσαμε στα αντίστοιχα αρχεία εξόδου που παράγει o McPAT τις εξής πληροφορίες:

Για το Xeon επεξεργαστή:

>Runtime Dynamic = 72.9199 W

>Total Leakage = 36.8319 W

Για τον ARM A9 επεξεργαστή:

>Runtime Dynamic = 2.96053 W

>Total Leakage = 0.108687 W

Οπότε,για να δούμε ποιος είναι πιο energy efficient κατα την διάρκεια της εκτέλεσης της εφαρμογής θα κάνω τους εξής υπολογισμούς:

Ef(Xeon)=(Runtime Dynamic) *  exec_time_Xeon=(72.9199) * X= 72.919 * Χ

Ef(ARM_A9)=(Runtime Dynamic) * exec_time_ARM_A9=
(2.96053) * 40X= 118.4212 * X

Αυτό που παρατηρούμε εδώ είναι ότι για τον Xeon παίρνουμε καλύτερο αποτέλεσμα αλλά η εκφώνηση μας λέει ότι μέτα τη εκτέλεση της εφαρμογής το σύστημα παραμένει ενεργό και ας μην χρησιμοποιούνται οι επεξεργαστές.Τότε υποθέτουμε ότι αυτοί μπαίνουν σε idle mode για χρόνο Υ seconds.Οπότε ο σωστός υπολογισμός του energy efficiency στην περίπτωση μας είναι ο παρακάτω:


Ef(Xeon)=(Runtime Dynamic) *  exec_time_Xeon + Total Leakage * idle_mode_time=72.919 * Χ + 36.8319 * Y

Ef(ARM_A9)=(Runtime Dynamic) * exec_time_ARM_A9 + Total Leakage * idle_mode_time=118.4212 * X +  0.108687 * Y

Και επειδή το μέγεθος του Total Leakage του Xeon είναι πολύ μεγαλύτερο από αυτό του ARM A9,ακόμα και ένα second να περάσουν οι δύο επεξεργαστές σε idle mode ο ARM A9 επεξεργαστής γίνεται πιο energy efficient από τον Xeon.

#### Βήμα 2ο

Στο δεύτερο βήμα της εργασίας μας ζητήθηκε κάνοντας χρήση του GEM5ToMcPAT.py εκτελέσιμου αρχείου να συνδιάσουμε τα αποτελέσματα που είχαμε πάρει από την 2η εργασία χρησιμοποιώντας τον gem5 και εξομειώνοντας συγκεριμένες αρχιτεκτονικές υπολογιστών με τον McPAT έτσι ώστε να υπολογίσουμε το γινόμενο Energy–Delay–Area(EDAP) και να προτείνουμε μία λύση που να το βελτιστοποιεί.

#### Ερώτημα 1ο 

Πραγματικά,το να βρεθεί η τιμή του όρου Area είναι πολύ εύκολο διότι την τυπώνει στα αποτελέσματα του ο McPAT.Πιο συγκεκρίμενα,για εμάς που θέλαμε να υπολογίσουμε την τιμή του Area αθροίζοντας τις τιμές για το core και την L2 cache θα πάμε στα παρακάτω πεδία των αποτελεσμάτων που παράγει ο McPAT και θα πάρουμε τις ανάλογες τιμές:

>Core:

>Area =

>L2

>Area =

Την τιμή του όρου Energy για την εκτέλεση κάποιας εφαρμογής πάνω σε ένα επεξεργαστή μπορούμε να την υπολογίσουμε πολλαπλασιάζοντας τους όρους Runtime Dynamic X sim_seconds.Τον όρο Runtime Dynamic θα τον πάρουμε από τα αποτελέσματα του McPAT και τον όρο sim_seconds από το αρχείο stats.txt που παράγει ο gem5.Βέβαια,στην συγκεκριμένη εργασία για να έχουμε μεγαλύτερη ακρίβεια αποτελεσμάτων χρησιμοποιήσαμε για τον υπολογισμό του όρου Energy το print_energy.py που υπάρχει στο αρχείο Scripts.Η τιμή του όρου Delay ταυτίζεται με την τιμή του sim_seconds που βρίσκεται στο αρχείο stats.txt από τα παραγόμενα αποτελέσματα του gem5.

#### Ερώτημα 2ο

Σε αυτό το ερώτημα θα παρουσιάσουμε με μορφή γραφημάτων την επίδραση που έχει η αλλάγη των τιμών των όρων cache line size,level 2 cache associativity και level 2 cache size στις τιμές του Area(υπολογίστηκε αθροίζοντας τα αντίστοιχα πεδία στα αποτελέσματα του McPAT για τον Core και L2) και Peak Power.Να τονίσουμε ότι οι τιμές των υπόλοιπων παραμέτρων είναι αυτές που δίνει ο gem5 by default και τις έχουμε παρουσιάσει στην 2η Εργασία του μαθήματος.Επίσης,επειδή οι τιμές αυτές είναι κοινές για όλες τις εκτελέσεις των benchmarks θα παρατηρήσετε ότι τα αποτελέσματα είναι ίδια όσο αναφορά τους όρους Area και Peak Power.

#### Area-Level 2 cache size

![AL2s](https://user-images.githubusercontent.com/57605047/71524643-0c707e00-28d7-11ea-8c16-5c8676f54406.png) 

Από το διάγραμμα αυτό που παρατηρούμε είναι ότι όσο αυξάνουμε το μέγεθος της Level 2 cache τόσο μεγαλώνει και το μέγεθος του Area.

#### Peak Power-Level 2 cache size

![PL2s](https://user-images.githubusercontent.com/57605047/71524681-3e81e000-28d7-11ea-8018-64c26f702ee8.png)

Και στο Peak Power βλέπουμε αύξηση όσο μεγαλώνει το μέγεθος της Level 2 cache.

#### Area-Level 2 cache associativity

![AL2a](https://user-images.githubusercontent.com/57605047/71524697-50fc1980-28d7-11ea-8bba-7fd6055dd964.png)

Τα αποτελέσματα που βλέπουμε εδώ διαφέρουν από τα προηγούμενα δίοτι βλέπουμε ότι το Area είναι μικρότερο όταν Level 2 cache associativity είναι ίσο με 8.Αυτό πιστεύουμε ότι συνδέεται με το γεγονός ότι το μέγεθος της L2 cache είναι ορισμένο by default στα 2ΜΒ.

#### Peak Power-Level 2 cache associativity

![PL2a](https://user-images.githubusercontent.com/57605047/71524715-70934200-28d7-11ea-8a47-c4e204ab166e.png)

Σε αυτό το διάγραμμα βλέπουμε ότι η αλλάγη στο Level 2 cache associativity δεν επηρέαζει την τιμή του Peak Power παρα μόνο σε πολύ μικρό βαθμό κάτι που είναι αναμενόμενο αφού από άποψη υλικού μέσα στον επεξεργαστή δεν αλλάζουν πολλά πράγματα όσο μεγαλώνουμε το associativity.

#### Area-Cache line size

![ACls](https://user-images.githubusercontent.com/57605047/71524735-886ac600-28d7-11ea-81e7-388375c82705.png)
 

Βλέπουμε ότι η αύξηση του cache line size από 64 bytes σε 128 bytes προκαλεί τεράστια αύξηση στην τιμή του Area ενώ στην αλλάγη από 32 bytes σε 64 bytes δεν παρατηρούμε ανάλογη αύξηση.

#### Peak Power-Cache line size

![PCls](https://user-images.githubusercontent.com/57605047/71524758-a0dae080-28d7-11ea-903f-c7b3fe3df20b.png)

Εδώ βλέπουμε ότι ο όρος Peak Power όταν αυξάνουμε το cache line size από 32 bytes σε 64 bytes μεγαλώνει κατα 25% και όταν το αυξάνουμε από 64 bytes σε 128 bytes υπερδιπλασιάζεται.

#### Ερώτημα 3ο

Αρχικά,θα παρουσιάσουμε για κάθε benchmark την λύση που βελτιστοποιεί το γινόμενο EDAP και έπειτα θα παρουσιάσουμε την συνολική λύση που θεωρούμε καλύτερη.Να τονίσουμε ότι τις τιμές του Area τις πήραμε από τα αποτελέσματα του McPAT,του Energy από το αποτέλεσμα που παράγει το print_energy.py που βρκεται στον φάκελο Scripts και το Delay από τον όρο sim_seconds που βρίσκεται στον φάκελο stats.txt που παράγει ο gem5 μετά από κάθε εξομοίωση.

**1. 401.bzip**

**Level 2 cache size** 1ΜΒ

**Level 2 cache associativity** 8

**Cache line size** 32bytes

**2. 429.mcf**

**Level 2 cache size** 1MB

**Level 2 cache associativity** 8

**Cache line size** 32bytes

**3. 456.hmmer**

**Level 2 cache size** 1MB

**Level 2 cache associativity** 8

**Cache line size** 32bytes

**4. 458.sjeng**

**Level 2 cache size** 1MB

**Level 2 cache associativity** 8

**Cache line size** 64bytes

**5. 470.libm**

**Level 2 cache size** 1MB

**Level 2 cache associativity** 8

**Cache line size** 64bytes

Συνολικά η καλύτερη λύση που έχουμε να προτείνουμε είναι η παρακάτω:

**Level 2 cache size** 1MB

**Level 2 cache associativity** 8

**Cache line size** 64bytes

Για το μέγεθος της Level 2 cache το 1ΜΒ είναι η καλύτερη λύση για όλα τα benchmarks.Επιλέξαμε το associativity της Level 2 cache να είναι 8 επειδή και πάλι είναι η καλύτερη λύση για όλα τα benchmarks.Τέλος,θεωρούμε ότι το cache line size πρέπει να είναι 64bytes,αν και στα τρία πρώτα benchmarks η βέλτιστη λύση είναι τα 32bytes,επειδή βλέπουμε ότι στα 32 bytes το γινόμενο EDAP μεγαλώνει σε πολύ μεγαλύτερο βαθμό στα benchmarks 470.libm και 458.sjeng από οτι στα υπόλοιπα benchmarks αν ορίσουμε το cache line size στα 64 bytes.

Σχετικά,με τα αποτελέσματα που προέκυψαν από την 2η Εργασία βλέπουμε ότι μελετώντας της τιμές που σχετίζονται με την Level 2 cache με γνώμονα το γινόμενο EDAP διαφέρουν πολύ από αυτές που βγάλαμε μέσω της συνάρτησης κόστους που είχαμε προτείνει.Πιο συγκεκριμένα:

**1.** Για το μέγεθος της cache στην 2η Εργασία είχαμε προτείνει τα 256Κb ενώ τώρα βρήκαμε ως καλύτερη το 1MB.Βέβαια,δεν τρέξαμε τον McPAT για 256Kb και βλέποντας το διάγραμμα από το 2ο Ερώτημα θεωρούμε ότι αυτή θα προέκυπτε ως βέλτιστη λύση σε σχέση με το γινόμενο EDAP.

**2.** Για το associativity στην 2η Εργασία είχαμε δώσει ως βέλτιστη λύση την 2-way set associative cache ενώ εδώ προκύπτει ως καλύτερη λύση η 8-way set associative.

**3.** Για το μέγεθος της cache line size είχαμε προτείνει τα 128bytes κάτι που βλέπουμε ότι αυξάνει σε τεράστιο βαθμό το γινόμενο EDAP.Οπότε,ως λύση σε αυτήν την εργασία προτείναμε τα 64 bytes.

Συνολικά,η καλύτερη λύση και για τις δύο εργασίες προκύπτει ανάλογα με βάση με ποιον παράγοντα επιλέγει ο κάθε αρχιτέκτονας ως σημαντικότερο(απόδοση,κόστος,EDAP).Εμείς μία λύση που έχουμε να προτείνουμε μελετώντας εποπτικά τα αποτελέσματα των δύο εργασιών είναι η παρακάτω:


**Level 2 cache size** 256Kb

**Level 2 cache associativity** 8

**Cache line size** 64bytes


#### Λίγα λόγια από εμάς

Στο σύνολο αυτή η εργασία ήταν πολύ επιμορφωτική για εμάς για πολλόυς λόγους.Οι δύο κυριότεροι ήταν ότι μας μύησε και μας εξικοίωσε με την χρήση ενός νεού και πολύ χρήσιμου εργαλέιου,του McPAT.Επίσης,μας έδειξε ότι στην σχεδίαση της αρχιτεκτονικής ενός επεξεργαστή ένας νέος σημαντικός παράγοντας που πρέπει να ληφθέι υπ´όψη είναι και η ενέργεια που απαιτεί η λειτουργία του αλλά και πόσο χώρο καταλαμβάνει.Όπως,και στις προηγούμενες εργασίες έτσι και σε αυτήν θεωρούμε ότι μπορεί να έχουν υπάρξει αστοχίες από πλευράς μας τις οποίες θα θελάμε αν είναι δυνατό να μας τις επισημάνετε και να μας υποδείξετε τις σωστές απαντήσεις.

#### Βιβλιογραφία

1.McPAT -Multicore Power, Area, and Timing [https://www.hpl.hp.com/research/mcpat/](https://www.hpl.hp.com/research/mcpat/) 

2.gem5 simulator wiki [http://gem5.org/Main_Page](http://gem5.org/Main_Page) 

3.gem5 assignment from Technical University of Eindhoven[https://sites.google.com/site/5md00gem5/assignment](https://sites.google.com/site/5md00gem5/assignment) 
